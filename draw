python

import phoebe
from phoebe import u # units
import numpy as np
import matplotlib.pyplot as plt

logger = phoebe.logger('error')

b = phoebe.default_binary()
#b.add_constraint('semidetached', 'secondary')
b.add_constraint('requivfrac',component='secondary',solve_for='requiv')
b['value@requivfrac@secondary@component']=0.99

b.set_value('period', component='binary', value=0.14*u.d)
b.set_value('teff', component='primary', value=30000*u.K)
b.set_value('teff', component='secondary', value=3650*u.K)
b.set_value('requiv', component='primary', value=0.01*u.solRad)
b['requiv@secondary@component']=b['value@requiv_max@secondary@component']*0.999*u.solRad
b.flip_constraint('mass@primary', solve_for='sma@binary')
b.set_value('mass', component='primary', value=0.8*u.solMass)
b.flip_constraint('mass@secondary', solve_for='q')
b.set_value('mass', component='secondary', value=0.2*u.solMass)



phases = phoebe.linspace(0,1,101)
b.add_dataset('lc', times=b.to_time(phases),dataset='lc01',overwrite=True, passband="Johnson:V")

b.set_value('atm', component='primary', value='blackbody')
b.set_value('ld_mode', component='primary', value='manual')
b.set_value('ld_func', component='primary', value='quadratic')
b.set_value('ld_coeffs', component='primary', dataset='lc01', value=[0.1225,0.3086])
b.set_value_all('ld_mode_bol@primary','manual')
b.set_value_all('ld_func_bol@primary','quadratic')
b.set_value('ld_coeffs_bol', component='primary', value=[0.1421,0.3693])

b.set_value_all('atm', component='secondary', value='phoenix')
b.set_value('abun', component='secondary', value=0)

b['distortion_method@primary']='sphere'
b.set_value('ntriangles@secondary', value=10000)

print(b.run_checks())
b.run_compute(model='WD_RD',overwrite=True)
b.plot(show=True)









import phoebe
b = phoebe.default_binary(semidetached=True,contact_binary=False,force_build=True)
b.add_dataset('lc', times=phoebe.linspace(0,2,101))
b.run_compute()
b.plot(show=True)


import phoebe
b = phoebe.default_binary()
b.add_constraint('semidetached', 'primary')
b.add_dataset('lc', times=phoebe.linspace(0,2,101))
b.run_compute()
b.plot(show=True)


default_binary(*args, **kwargs)
    For convenience, this function is available at the top-level as
    <phoebe.default_binary> as well as
    <phoebe.frontend.bundle.Bundle.default_binary>.

    Load a bundle with a default binary as the system.

    primary - secondary

    This is a constructor, so should be called as:

    ```py
    b = Bundle.default_binary()
    ```

    Arguments
    -----------
    * `starA` (string, optional, default='primary'): the label to be set for
        the primary component.
    * `starB` (string, optional, default='secondary'): the label to be set for
        the secondary component.
    * `orbit` (string, optional, default='binary'): the label to be set for
        the binary component.
    * `semidetached` (string or bool, optional, default=False): component
        to apply a semidetached constraint.  If False, system will be detached.
        If True, both components will have semidetached constraints (a
        double-contact system).  `contact_binary` must be False.
    * `contact_binary` (bool, optional, default=False): whether to also
        add an envelope (with component='contact_envelope') and set the
        hierarchy to a contact binary system.  `semidetached` must be False.
    * `force_build` (bool, optional, default=False): whether to force building
        the bundle from scratch.  If False, pre-cached files will be loaded
        whenever possible to save time.

    Returns
    -----------
    * an instantiated <phoebe.frontend.bundle.Bundle> object.

    Raises
    -----------
    * ValueError: if at least one of `semidetached` and `contact_binary` are
        not False.
        
        
  
b = phoebe.default_binary()
b.add_constraint('requivfrac', component='primary',solve_for='requiv')
b['requivfrac@primary@component']=0.9*u.solRad
print(b['requivfrac@primary@constraint'])
print('-'*100)
print(b['requiv@primary@constraint'])
print('-'*100)
print(b['sma@binary@constraint'])
